{"title": "Maximum Element", "time-limit": 2000, "memory-limit": 256, "props": {"following code": " int fast", "Server time": "  Dec"}, "statement": "E. Maximum Element time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of  n  positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter  k , so now his function contains the following code: int fast_max(int n, int a[]) {      int ans = 0;     int offset = 0;     for (int i = 0; i < n; ++i)         if (ans < a[i]) {             ans = a[i];             offset = 0;         } else {             offset = offset + 1;             if (offset == k)                 return ans;         }     return ans; } That way the function iteratively checks array elements, storing the intermediate maximum, and if after  k  consecutive iterations that maximum has not changed, it is returned as the answer. Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from  1  to  n  such that the return value of his function on those permutations is not equal to  n . Since this number could be very big, output the answer modulo  10 9 \u2009+\u20097 . Input The only line contains two integers  n  and  k  ( 1\u2009\u2264\u2009 n ,\u2009 k \u2009\u2264\u200910 6 ), separated by a space\u00a0\u2014 the length of the permutations and the parameter  k . Output Output the answer to the problem modulo  10 9 \u2009+\u20097 . Examples Input 5 2 Output 22 Input 5 3 Output 6 Input 6 3 Output 84 Note Permutations from second example:  [4,\u20091,\u20092,\u20093,\u20095] ,  [4,\u20091,\u20093,\u20092,\u20095] ,  [4,\u20092,\u20091,\u20093,\u20095] ,  [4,\u20092,\u20093,\u20091,\u20095] ,  [4,\u20093,\u20091,\u20092,\u20095] ,  [4,\u20093,\u20092,\u20091,\u20095] . E. Maximum Element time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of  n  positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter  k , so now his function contains the following code: int fast_max(int n, int a[]) {      int ans = 0;     int offset = 0;     for (int i = 0; i < n; ++i)         if (ans < a[i]) {             ans = a[i];             offset = 0;         } else {             offset = offset + 1;             if (offset == k)                 return ans;         }     return ans; } That way the function iteratively checks array elements, storing the intermediate maximum, and if after  k  consecutive iterations that maximum has not changed, it is returned as the answer. Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from  1  to  n  such that the return value of his function on those permutations is not equal to  n . Since this number could be very big, output the answer modulo  10 9 \u2009+\u20097 . Input The only line contains two integers  n  and  k  ( 1\u2009\u2264\u2009 n ,\u2009 k \u2009\u2264\u200910 6 ), separated by a space\u00a0\u2014 the length of the permutations and the parameter  k . Output Output the answer to the problem modulo  10 9 \u2009+\u20097 . Examples Input 5 2 Output 22 Input 5 3 Output 6 Input 6 3 Output 84 Note Permutations from second example:  [4,\u20091,\u20092,\u20093,\u20095] ,  [4,\u20091,\u20093,\u20092,\u20095] ,  [4,\u20092,\u20091,\u20093,\u20095] ,  [4,\u20092,\u20093,\u20091,\u20095] ,  [4,\u20093,\u20091,\u20092,\u20095] ,  [4,\u20093,\u20092,\u20091,\u20095] . E. Maximum Element time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of  n  positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter  k , so now his function contains the following code: int fast_max(int n, int a[]) {      int ans = 0;     int offset = 0;     for (int i = 0; i < n; ++i)         if (ans < a[i]) {             ans = a[i];             offset = 0;         } else {             offset = offset + 1;             if (offset == k)                 return ans;         }     return ans; } That way the function iteratively checks array elements, storing the intermediate maximum, and if after  k  consecutive iterations that maximum has not changed, it is returned as the answer. Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from  1  to  n  such that the return value of his function on those permutations is not equal to  n . Since this number could be very big, output the answer modulo  10 9 \u2009+\u20097 . Input The only line contains two integers  n  and  k  ( 1\u2009\u2264\u2009 n ,\u2009 k \u2009\u2264\u200910 6 ), separated by a space\u00a0\u2014 the length of the permutations and the parameter  k . Output Output the answer to the problem modulo  10 9 \u2009+\u20097 . Examples Input 5 2 Output 22 Input 5 3 Output 6 Input 6 3 Output 84 Note Permutations from second example:  [4,\u20091,\u20092,\u20093,\u20095] ,  [4,\u20091,\u20093,\u20092,\u20095] ,  [4,\u20092,\u20091,\u20093,\u20095] ,  [4,\u20092,\u20093,\u20091,\u20095] ,  [4,\u20093,\u20091,\u20092,\u20095] ,  [4,\u20093,\u20092,\u20091,\u20095] . E. Maximum Element time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of  n  positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter  k , so now his function contains the following code: int fast_max(int n, int a[]) {      int ans = 0;     int offset = 0;     for (int i = 0; i < n; ++i)         if (ans < a[i]) {             ans = a[i];             offset = 0;         } else {             offset = offset + 1;             if (offset == k)                 return ans;         }     return ans; } That way the function iteratively checks array elements, storing the intermediate maximum, and if after  k  consecutive iterations that maximum has not changed, it is returned as the answer. Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from  1  to  n  such that the return value of his function on those permutations is not equal to  n . Since this number could be very big, output the answer modulo  10 9 \u2009+\u20097 . Input The only line contains two integers  n  and  k  ( 1\u2009\u2264\u2009 n ,\u2009 k \u2009\u2264\u200910 6 ), separated by a space\u00a0\u2014 the length of the permutations and the parameter  k . Output Output the answer to the problem modulo  10 9 \u2009+\u20097 . Examples Input 5 2 Output 22 Input 5 3 Output 6 Input 6 3 Output 84 Note Permutations from second example:  [4,\u20091,\u20092,\u20093,\u20095] ,  [4,\u20091,\u20093,\u20092,\u20095] ,  [4,\u20092,\u20091,\u20093,\u20095] ,  [4,\u20092,\u20093,\u20091,\u20095] ,  [4,\u20093,\u20091,\u20092,\u20095] ,  [4,\u20093,\u20092,\u20091,\u20095] . E. Maximum Element time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of  n  positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter  k , so now his function contains the following code: int fast_max(int n, int a[]) {      int ans = 0;     int offset = 0;     for (int i = 0; i < n; ++i)         if (ans < a[i]) {             ans = a[i];             offset = 0;         } else {             offset = offset + 1;             if (offset == k)                 return ans;         }     return ans; } That way the function iteratively checks array elements, storing the intermediate maximum, and if after  k  consecutive iterations that maximum has not changed, it is returned as the answer. Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from  1  to  n  such that the return value of his function on those permutations is not equal to  n . Since this number could be very big, output the answer modulo  10 9 \u2009+\u20097 . Input The only line contains two integers  n  and  k  ( 1\u2009\u2264\u2009 n ,\u2009 k \u2009\u2264\u200910 6 ), separated by a space\u00a0\u2014 the length of the permutations and the parameter  k . Output Output the answer to the problem modulo  10 9 \u2009+\u20097 . Examples Input 5 2 Output 22 Input 5 3 Output 6 Input 6 3 Output 84 Note Permutations from second example:  [4,\u20091,\u20092,\u20093,\u20095] ,  [4,\u20091,\u20093,\u20092,\u20095] ,  [4,\u20092,\u20091,\u20093,\u20095] ,  [4,\u20092,\u20093,\u20091,\u20095] ,  [4,\u20093,\u20091,\u20092,\u20095] ,  [4,\u20093,\u20092,\u20091,\u20095] . E. Maximum Element time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of  n  positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter  k , so now his function contains the following code: int fast_max(int n, int a[]) {      int ans = 0;     int offset = 0;     for (int i = 0; i < n; ++i)         if (ans < a[i]) {             ans = a[i];             offset = 0;         } else {             offset = offset + 1;             if (offset == k)                 return ans;         }     return ans; } That way the function iteratively checks array elements, storing the intermediate maximum, and if after  k  consecutive iterations that maximum has not changed, it is returned as the answer. Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from  1  to  n  such that the return value of his function on those permutations is not equal to  n . Since this number could be very big, output the answer modulo  10 9 \u2009+\u20097 . Input The only line contains two integers  n  and  k  ( 1\u2009\u2264\u2009 n ,\u2009 k \u2009\u2264\u200910 6 ), separated by a space\u00a0\u2014 the length of the permutations and the parameter  k . Output Output the answer to the problem modulo  10 9 \u2009+\u20097 . Examples Input 5 2 Output 22 Input 5 3 Output 6 Input 6 3 Output 84 Note Permutations from second example:  [4,\u20091,\u20092,\u20093,\u20095] ,  [4,\u20091,\u20093,\u20092,\u20095] ,  [4,\u20092,\u20091,\u20093,\u20095] ,  [4,\u20092,\u20093,\u20091,\u20095] ,  [4,\u20093,\u20091,\u20092,\u20095] ,  [4,\u20093,\u20092,\u20091,\u20095] . E. Maximum Element time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of  n  positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter  k , so now his function contains the following code: int fast_max(int n, int a[]) {      int ans = 0;     int offset = 0;     for (int i = 0; i < n; ++i)         if (ans < a[i]) {             ans = a[i];             offset = 0;         } else {             offset = offset + 1;             if (offset == k)                 return ans;         }     return ans; } That way the function iteratively checks array elements, storing the intermediate maximum, and if after  k  consecutive iterations that maximum has not changed, it is returned as the answer. Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from  1  to  n  such that the return value of his function on those permutations is not equal to  n . Since this number could be very big, output the answer modulo  10 9 \u2009+\u20097 . Input The only line contains two integers  n  and  k  ( 1\u2009\u2264\u2009 n ,\u2009 k \u2009\u2264\u200910 6 ), separated by a space\u00a0\u2014 the length of the permutations and the parameter  k . Output Output the answer to the problem modulo  10 9 \u2009+\u20097 . Examples Input 5 2 Output 22 Input 5 3 Output 6 Input 6 3 Output 84 Note Permutations from second example:  [4,\u20091,\u20092,\u20093,\u20095] ,  [4,\u20091,\u20093,\u20092,\u20095] ,  [4,\u20092,\u20091,\u20093,\u20095] ,  [4,\u20092,\u20093,\u20091,\u20095] ,  [4,\u20093,\u20091,\u20092,\u20095] ,  [4,\u20093,\u20092,\u20091,\u20095] . E. Maximum Element time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of  n  positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter  k , so now his function contains the following code: int fast_max(int n, int a[]) {      int ans = 0;     int offset = 0;     for (int i = 0; i < n; ++i)         if (ans < a[i]) {             ans = a[i];             offset = 0;         } else {             offset = offset + 1;             if (offset == k)                 return ans;         }     return ans; } That way the function iteratively checks array elements, storing the intermediate maximum, and if after  k  consecutive iterations that maximum has not changed, it is returned as the answer. Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from  1  to  n  such that the return value of his function on those permutations is not equal to  n . Since this number could be very big, output the answer modulo  10 9 \u2009+\u20097 . Input The only line contains two integers  n  and  k  ( 1\u2009\u2264\u2009 n ,\u2009 k \u2009\u2264\u200910 6 ), separated by a space\u00a0\u2014 the length of the permutations and the parameter  k . Output Output the answer to the problem modulo  10 9 \u2009+\u20097 . Examples Input 5 2 Output 22 Input 5 3 Output 6 Input 6 3 Output 84 Note Permutations from second example:  [4,\u20091,\u20092,\u20093,\u20095] ,  [4,\u20091,\u20093,\u20092,\u20095] ,  [4,\u20092,\u20091,\u20093,\u20095] ,  [4,\u20092,\u20093,\u20091,\u20095] ,  [4,\u20093,\u20091,\u20092,\u20095] ,  [4,\u20093,\u20092,\u20091,\u20095] ."}