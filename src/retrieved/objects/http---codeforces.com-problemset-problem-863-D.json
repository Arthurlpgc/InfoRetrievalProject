{"props": {"Server time": "  Oct", "two types": "      1 "}, "title": "Yet Another Array Queries Problem", "time-limit": 2000, "statement": "D. Yet Another Array Queries Problem time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output You are given an array  a  of size  n , and  q  queries to it. There are queries of two types:      1   l i   r i  \u2014 perform a cyclic shift of the segment  [ l i ,\u2009 r i ]  to the right. That is, for every  x  such that  l i \u2009\u2264\u2009 x \u2009<\u2009 r i  new value of  a x \u2009+\u20091  becomes equal to old value of  a x , and new value of  a l i  becomes equal to old value of  a r i ;    2   l i   r i  \u2014 reverse the segment  [ l i ,\u2009 r i ] .    There are  m  important indices in the array  b 1 ,  b 2 , ...,  b m . For each  i  such that  1\u2009\u2264\u2009 i \u2009\u2264\u2009 m  you have to output the number that will have index  b i  in the array after all queries are performed. Input The first line contains three integer numbers  n ,  q  and  m  ( 1\u2009\u2264\u2009 n ,\u2009 q \u2009\u2264\u20092\u00b710 5 ,  1\u2009\u2264\u2009 m \u2009\u2264\u2009100 ).  The second line contains  n  integer numbers  a 1 ,  a 2 , ...,  a n  ( 1\u2009\u2264\u2009 a i \u2009\u2264\u200910 9 ).  Then  q  lines follow.  i -th of them contains three integer numbers  t i ,  l i ,  r i , where  t i  is the type of  i -th query, and  [ l i ,\u2009 r i ]  is the segment where this query is performed ( 1\u2009\u2264\u2009 t i \u2009\u2264\u20092 ,  1\u2009\u2264\u2009 l i \u2009\u2264\u2009 r i \u2009\u2264\u2009 n ).  The last line contains  m  integer numbers  b 1 ,  b 2 , ...,  b m  ( 1\u2009\u2264\u2009 b i \u2009\u2264\u2009 n ) \u2014 important indices of the array.  Output Print  m  numbers,  i -th of which is equal to the number at index  b i  after all queries are done. Example Input 6 3 5 1 2 3 4 5 6 2 1 3 2 3 6 1 1 6 2 2 1 5 3 Output 3 3 1 5 2  D. Yet Another Array Queries Problem time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output You are given an array  a  of size  n , and  q  queries to it. There are queries of two types:      1   l i   r i  \u2014 perform a cyclic shift of the segment  [ l i ,\u2009 r i ]  to the right. That is, for every  x  such that  l i \u2009\u2264\u2009 x \u2009<\u2009 r i  new value of  a x \u2009+\u20091  becomes equal to old value of  a x , and new value of  a l i  becomes equal to old value of  a r i ;    2   l i   r i  \u2014 reverse the segment  [ l i ,\u2009 r i ] .    There are  m  important indices in the array  b 1 ,  b 2 , ...,  b m . For each  i  such that  1\u2009\u2264\u2009 i \u2009\u2264\u2009 m  you have to output the number that will have index  b i  in the array after all queries are performed. Input The first line contains three integer numbers  n ,  q  and  m  ( 1\u2009\u2264\u2009 n ,\u2009 q \u2009\u2264\u20092\u00b710 5 ,  1\u2009\u2264\u2009 m \u2009\u2264\u2009100 ).  The second line contains  n  integer numbers  a 1 ,  a 2 , ...,  a n  ( 1\u2009\u2264\u2009 a i \u2009\u2264\u200910 9 ).  Then  q  lines follow.  i -th of them contains three integer numbers  t i ,  l i ,  r i , where  t i  is the type of  i -th query, and  [ l i ,\u2009 r i ]  is the segment where this query is performed ( 1\u2009\u2264\u2009 t i \u2009\u2264\u20092 ,  1\u2009\u2264\u2009 l i \u2009\u2264\u2009 r i \u2009\u2264\u2009 n ).  The last line contains  m  integer numbers  b 1 ,  b 2 , ...,  b m  ( 1\u2009\u2264\u2009 b i \u2009\u2264\u2009 n ) \u2014 important indices of the array.  Output Print  m  numbers,  i -th of which is equal to the number at index  b i  after all queries are done. Example Input 6 3 5 1 2 3 4 5 6 2 1 3 2 3 6 1 1 6 2 2 1 5 3 Output 3 3 1 5 2  D. Yet Another Array Queries Problem time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output You are given an array  a  of size  n , and  q  queries to it. There are queries of two types:      1   l i   r i  \u2014 perform a cyclic shift of the segment  [ l i ,\u2009 r i ]  to the right. That is, for every  x  such that  l i \u2009\u2264\u2009 x \u2009<\u2009 r i  new value of  a x \u2009+\u20091  becomes equal to old value of  a x , and new value of  a l i  becomes equal to old value of  a r i ;    2   l i   r i  \u2014 reverse the segment  [ l i ,\u2009 r i ] .    There are  m  important indices in the array  b 1 ,  b 2 , ...,  b m . For each  i  such that  1\u2009\u2264\u2009 i \u2009\u2264\u2009 m  you have to output the number that will have index  b i  in the array after all queries are performed. Input The first line contains three integer numbers  n ,  q  and  m  ( 1\u2009\u2264\u2009 n ,\u2009 q \u2009\u2264\u20092\u00b710 5 ,  1\u2009\u2264\u2009 m \u2009\u2264\u2009100 ).  The second line contains  n  integer numbers  a 1 ,  a 2 , ...,  a n  ( 1\u2009\u2264\u2009 a i \u2009\u2264\u200910 9 ).  Then  q  lines follow.  i -th of them contains three integer numbers  t i ,  l i ,  r i , where  t i  is the type of  i -th query, and  [ l i ,\u2009 r i ]  is the segment where this query is performed ( 1\u2009\u2264\u2009 t i \u2009\u2264\u20092 ,  1\u2009\u2264\u2009 l i \u2009\u2264\u2009 r i \u2009\u2264\u2009 n ).  The last line contains  m  integer numbers  b 1 ,  b 2 , ...,  b m  ( 1\u2009\u2264\u2009 b i \u2009\u2264\u2009 n ) \u2014 important indices of the array.  Output Print  m  numbers,  i -th of which is equal to the number at index  b i  after all queries are done. Example Input 6 3 5 1 2 3 4 5 6 2 1 3 2 3 6 1 1 6 2 2 1 5 3 Output 3 3 1 5 2  D. Yet Another Array Queries Problem time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output You are given an array  a  of size  n , and  q  queries to it. There are queries of two types:      1   l i   r i  \u2014 perform a cyclic shift of the segment  [ l i ,\u2009 r i ]  to the right. That is, for every  x  such that  l i \u2009\u2264\u2009 x \u2009<\u2009 r i  new value of  a x \u2009+\u20091  becomes equal to old value of  a x , and new value of  a l i  becomes equal to old value of  a r i ;    2   l i   r i  \u2014 reverse the segment  [ l i ,\u2009 r i ] .    There are  m  important indices in the array  b 1 ,  b 2 , ...,  b m . For each  i  such that  1\u2009\u2264\u2009 i \u2009\u2264\u2009 m  you have to output the number that will have index  b i  in the array after all queries are performed. Input The first line contains three integer numbers  n ,  q  and  m  ( 1\u2009\u2264\u2009 n ,\u2009 q \u2009\u2264\u20092\u00b710 5 ,  1\u2009\u2264\u2009 m \u2009\u2264\u2009100 ).  The second line contains  n  integer numbers  a 1 ,  a 2 , ...,  a n  ( 1\u2009\u2264\u2009 a i \u2009\u2264\u200910 9 ).  Then  q  lines follow.  i -th of them contains three integer numbers  t i ,  l i ,  r i , where  t i  is the type of  i -th query, and  [ l i ,\u2009 r i ]  is the segment where this query is performed ( 1\u2009\u2264\u2009 t i \u2009\u2264\u20092 ,  1\u2009\u2264\u2009 l i \u2009\u2264\u2009 r i \u2009\u2264\u2009 n ).  The last line contains  m  integer numbers  b 1 ,  b 2 , ...,  b m  ( 1\u2009\u2264\u2009 b i \u2009\u2264\u2009 n ) \u2014 important indices of the array.  Output Print  m  numbers,  i -th of which is equal to the number at index  b i  after all queries are done. Example Input 6 3 5 1 2 3 4 5 6 2 1 3 2 3 6 1 1 6 2 2 1 5 3 Output 3 3 1 5 2  D. Yet Another Array Queries Problem time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output You are given an array  a  of size  n , and  q  queries to it. There are queries of two types:      1   l i   r i  \u2014 perform a cyclic shift of the segment  [ l i ,\u2009 r i ]  to the right. That is, for every  x  such that  l i \u2009\u2264\u2009 x \u2009<\u2009 r i  new value of  a x \u2009+\u20091  becomes equal to old value of  a x , and new value of  a l i  becomes equal to old value of  a r i ;    2   l i   r i  \u2014 reverse the segment  [ l i ,\u2009 r i ] .    There are  m  important indices in the array  b 1 ,  b 2 , ...,  b m . For each  i  such that  1\u2009\u2264\u2009 i \u2009\u2264\u2009 m  you have to output the number that will have index  b i  in the array after all queries are performed. Input The first line contains three integer numbers  n ,  q  and  m  ( 1\u2009\u2264\u2009 n ,\u2009 q \u2009\u2264\u20092\u00b710 5 ,  1\u2009\u2264\u2009 m \u2009\u2264\u2009100 ).  The second line contains  n  integer numbers  a 1 ,  a 2 , ...,  a n  ( 1\u2009\u2264\u2009 a i \u2009\u2264\u200910 9 ).  Then  q  lines follow.  i -th of them contains three integer numbers  t i ,  l i ,  r i , where  t i  is the type of  i -th query, and  [ l i ,\u2009 r i ]  is the segment where this query is performed ( 1\u2009\u2264\u2009 t i \u2009\u2264\u20092 ,  1\u2009\u2264\u2009 l i \u2009\u2264\u2009 r i \u2009\u2264\u2009 n ).  The last line contains  m  integer numbers  b 1 ,  b 2 , ...,  b m  ( 1\u2009\u2264\u2009 b i \u2009\u2264\u2009 n ) \u2014 important indices of the array.  Output Print  m  numbers,  i -th of which is equal to the number at index  b i  after all queries are done. Example Input 6 3 5 1 2 3 4 5 6 2 1 3 2 3 6 1 1 6 2 2 1 5 3 Output 3 3 1 5 2  D. Yet Another Array Queries Problem time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output You are given an array  a  of size  n , and  q  queries to it. There are queries of two types:      1   l i   r i  \u2014 perform a cyclic shift of the segment  [ l i ,\u2009 r i ]  to the right. That is, for every  x  such that  l i \u2009\u2264\u2009 x \u2009<\u2009 r i  new value of  a x \u2009+\u20091  becomes equal to old value of  a x , and new value of  a l i  becomes equal to old value of  a r i ;    2   l i   r i  \u2014 reverse the segment  [ l i ,\u2009 r i ] .    There are  m  important indices in the array  b 1 ,  b 2 , ...,  b m . For each  i  such that  1\u2009\u2264\u2009 i \u2009\u2264\u2009 m  you have to output the number that will have index  b i  in the array after all queries are performed. Input The first line contains three integer numbers  n ,  q  and  m  ( 1\u2009\u2264\u2009 n ,\u2009 q \u2009\u2264\u20092\u00b710 5 ,  1\u2009\u2264\u2009 m \u2009\u2264\u2009100 ).  The second line contains  n  integer numbers  a 1 ,  a 2 , ...,  a n  ( 1\u2009\u2264\u2009 a i \u2009\u2264\u200910 9 ).  Then  q  lines follow.  i -th of them contains three integer numbers  t i ,  l i ,  r i , where  t i  is the type of  i -th query, and  [ l i ,\u2009 r i ]  is the segment where this query is performed ( 1\u2009\u2264\u2009 t i \u2009\u2264\u20092 ,  1\u2009\u2264\u2009 l i \u2009\u2264\u2009 r i \u2009\u2264\u2009 n ).  The last line contains  m  integer numbers  b 1 ,  b 2 , ...,  b m  ( 1\u2009\u2264\u2009 b i \u2009\u2264\u2009 n ) \u2014 important indices of the array.  Output Print  m  numbers,  i -th of which is equal to the number at index  b i  after all queries are done. Example Input 6 3 5 1 2 3 4 5 6 2 1 3 2 3 6 1 1 6 2 2 1 5 3 Output 3 3 1 5 2  D. Yet Another Array Queries Problem time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output You are given an array  a  of size  n , and  q  queries to it. There are queries of two types:      1   l i   r i  \u2014 perform a cyclic shift of the segment  [ l i ,\u2009 r i ]  to the right. That is, for every  x  such that  l i \u2009\u2264\u2009 x \u2009<\u2009 r i  new value of  a x \u2009+\u20091  becomes equal to old value of  a x , and new value of  a l i  becomes equal to old value of  a r i ;    2   l i   r i  \u2014 reverse the segment  [ l i ,\u2009 r i ] .    There are  m  important indices in the array  b 1 ,  b 2 , ...,  b m . For each  i  such that  1\u2009\u2264\u2009 i \u2009\u2264\u2009 m  you have to output the number that will have index  b i  in the array after all queries are performed. Input The first line contains three integer numbers  n ,  q  and  m  ( 1\u2009\u2264\u2009 n ,\u2009 q \u2009\u2264\u20092\u00b710 5 ,  1\u2009\u2264\u2009 m \u2009\u2264\u2009100 ).  The second line contains  n  integer numbers  a 1 ,  a 2 , ...,  a n  ( 1\u2009\u2264\u2009 a i \u2009\u2264\u200910 9 ).  Then  q  lines follow.  i -th of them contains three integer numbers  t i ,  l i ,  r i , where  t i  is the type of  i -th query, and  [ l i ,\u2009 r i ]  is the segment where this query is performed ( 1\u2009\u2264\u2009 t i \u2009\u2264\u20092 ,  1\u2009\u2264\u2009 l i \u2009\u2264\u2009 r i \u2009\u2264\u2009 n ).  The last line contains  m  integer numbers  b 1 ,  b 2 , ...,  b m  ( 1\u2009\u2264\u2009 b i \u2009\u2264\u2009 n ) \u2014 important indices of the array.  Output Print  m  numbers,  i -th of which is equal to the number at index  b i  after all queries are done. Example Input 6 3 5 1 2 3 4 5 6 2 1 3 2 3 6 1 1 6 2 2 1 5 3 Output 3 3 1 5 2  D. Yet Another Array Queries Problem time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output You are given an array  a  of size  n , and  q  queries to it. There are queries of two types:      1   l i   r i  \u2014 perform a cyclic shift of the segment  [ l i ,\u2009 r i ]  to the right. That is, for every  x  such that  l i \u2009\u2264\u2009 x \u2009<\u2009 r i  new value of  a x \u2009+\u20091  becomes equal to old value of  a x , and new value of  a l i  becomes equal to old value of  a r i ;    2   l i   r i  \u2014 reverse the segment  [ l i ,\u2009 r i ] .    There are  m  important indices in the array  b 1 ,  b 2 , ...,  b m . For each  i  such that  1\u2009\u2264\u2009 i \u2009\u2264\u2009 m  you have to output the number that will have index  b i  in the array after all queries are performed. Input The first line contains three integer numbers  n ,  q  and  m  ( 1\u2009\u2264\u2009 n ,\u2009 q \u2009\u2264\u20092\u00b710 5 ,  1\u2009\u2264\u2009 m \u2009\u2264\u2009100 ).  The second line contains  n  integer numbers  a 1 ,  a 2 , ...,  a n  ( 1\u2009\u2264\u2009 a i \u2009\u2264\u200910 9 ).  Then  q  lines follow.  i -th of them contains three integer numbers  t i ,  l i ,  r i , where  t i  is the type of  i -th query, and  [ l i ,\u2009 r i ]  is the segment where this query is performed ( 1\u2009\u2264\u2009 t i \u2009\u2264\u20092 ,  1\u2009\u2264\u2009 l i \u2009\u2264\u2009 r i \u2009\u2264\u2009 n ).  The last line contains  m  integer numbers  b 1 ,  b 2 , ...,  b m  ( 1\u2009\u2264\u2009 b i \u2009\u2264\u2009 n ) \u2014 important indices of the array.  Output Print  m  numbers,  i -th of which is equal to the number at index  b i  after all queries are done. Example Input 6 3 5 1 2 3 4 5 6 2 1 3 2 3 6 1 1 6 2 2 1 5 3 Output 3 3 1 5 2 ", "memory-limit": 256}