{"props": {"Server time": "  Oct", "by letters": "  a "}, "title": "Hex Dyslexia", "time-limit": 3000, "statement": "E. Hex Dyslexia time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Copying large hexadecimal (base 16) strings by hand can be error prone, but that doesn't stop people from doing it. You've discovered a bug in the code that was likely caused by someone making a mistake when copying such a string. You suspect that whoever copied the string did not change any of the digits in the string, nor the length of the string, but may have permuted the digits arbitrarily. For example, if the original string was  0 abc  they may have changed it to  a 0 cb  or  0 bca , but not  abc  or  0 abb . Unfortunately you don't have access to the original string nor the copied string, but you do know the length of the strings and their numerical absolute difference. You will be given this difference as a hexadecimal string  S , which has been zero-extended to be equal in length to the original and copied strings. Determine the smallest possible numerical value of the original string. Input Input will contain a hexadecimal string  S  consisting only of digits  0  to  9  and lowercase English letters from  a  to  f , with length at most  14 . At least one of the characters is non-zero. Output If it is not possible, print \" NO \" (without quotes). Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct. Examples Input f1e Output NO Input 0f1e Output 00f1 Input 12d2c Output 00314 Note The numerical value of a hexadecimal string is computed by multiplying each digit by successive powers of  16 , starting with the rightmost digit, which is multiplied by  16 0 . Hexadecimal digits representing values greater than  9  are represented by letters:  a \u2009=\u200910,\u2009 b \u2009=\u200911,\u2009 c \u2009=\u200912,\u2009 d \u2009=\u200913,\u2009 e \u2009=\u200914,\u2009 f \u2009=\u200915 . For example, the numerical value of  0 f 1 e  is  0\u00b716 3 \u2009+\u200915\u00b716 2 \u2009+\u20091\u00b716 1 \u2009+\u200914\u00b716 0 \u2009=\u20093870 , the numerical value of  00 f 1  is  0\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u200915\u00b716 1 \u2009+\u20091\u00b716 0 \u2009=\u2009241 , and the numerical value of  100 f  is  1\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u20090\u00b716 1 \u2009+\u200915\u00b716 0 \u2009=\u20094111 . Since  3870\u2009+\u2009241\u2009=\u20094111  and  00 f 1  is a permutation of  100 f ,  00 f 1  is a valid answer to the second test case. E. Hex Dyslexia time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Copying large hexadecimal (base 16) strings by hand can be error prone, but that doesn't stop people from doing it. You've discovered a bug in the code that was likely caused by someone making a mistake when copying such a string. You suspect that whoever copied the string did not change any of the digits in the string, nor the length of the string, but may have permuted the digits arbitrarily. For example, if the original string was  0 abc  they may have changed it to  a 0 cb  or  0 bca , but not  abc  or  0 abb . Unfortunately you don't have access to the original string nor the copied string, but you do know the length of the strings and their numerical absolute difference. You will be given this difference as a hexadecimal string  S , which has been zero-extended to be equal in length to the original and copied strings. Determine the smallest possible numerical value of the original string. Input Input will contain a hexadecimal string  S  consisting only of digits  0  to  9  and lowercase English letters from  a  to  f , with length at most  14 . At least one of the characters is non-zero. Output If it is not possible, print \" NO \" (without quotes). Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct. Examples Input f1e Output NO Input 0f1e Output 00f1 Input 12d2c Output 00314 Note The numerical value of a hexadecimal string is computed by multiplying each digit by successive powers of  16 , starting with the rightmost digit, which is multiplied by  16 0 . Hexadecimal digits representing values greater than  9  are represented by letters:  a \u2009=\u200910,\u2009 b \u2009=\u200911,\u2009 c \u2009=\u200912,\u2009 d \u2009=\u200913,\u2009 e \u2009=\u200914,\u2009 f \u2009=\u200915 . For example, the numerical value of  0 f 1 e  is  0\u00b716 3 \u2009+\u200915\u00b716 2 \u2009+\u20091\u00b716 1 \u2009+\u200914\u00b716 0 \u2009=\u20093870 , the numerical value of  00 f 1  is  0\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u200915\u00b716 1 \u2009+\u20091\u00b716 0 \u2009=\u2009241 , and the numerical value of  100 f  is  1\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u20090\u00b716 1 \u2009+\u200915\u00b716 0 \u2009=\u20094111 . Since  3870\u2009+\u2009241\u2009=\u20094111  and  00 f 1  is a permutation of  100 f ,  00 f 1  is a valid answer to the second test case. E. Hex Dyslexia time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Copying large hexadecimal (base 16) strings by hand can be error prone, but that doesn't stop people from doing it. You've discovered a bug in the code that was likely caused by someone making a mistake when copying such a string. You suspect that whoever copied the string did not change any of the digits in the string, nor the length of the string, but may have permuted the digits arbitrarily. For example, if the original string was  0 abc  they may have changed it to  a 0 cb  or  0 bca , but not  abc  or  0 abb . Unfortunately you don't have access to the original string nor the copied string, but you do know the length of the strings and their numerical absolute difference. You will be given this difference as a hexadecimal string  S , which has been zero-extended to be equal in length to the original and copied strings. Determine the smallest possible numerical value of the original string. Input Input will contain a hexadecimal string  S  consisting only of digits  0  to  9  and lowercase English letters from  a  to  f , with length at most  14 . At least one of the characters is non-zero. Output If it is not possible, print \" NO \" (without quotes). Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct. Examples Input f1e Output NO Input 0f1e Output 00f1 Input 12d2c Output 00314 Note The numerical value of a hexadecimal string is computed by multiplying each digit by successive powers of  16 , starting with the rightmost digit, which is multiplied by  16 0 . Hexadecimal digits representing values greater than  9  are represented by letters:  a \u2009=\u200910,\u2009 b \u2009=\u200911,\u2009 c \u2009=\u200912,\u2009 d \u2009=\u200913,\u2009 e \u2009=\u200914,\u2009 f \u2009=\u200915 . For example, the numerical value of  0 f 1 e  is  0\u00b716 3 \u2009+\u200915\u00b716 2 \u2009+\u20091\u00b716 1 \u2009+\u200914\u00b716 0 \u2009=\u20093870 , the numerical value of  00 f 1  is  0\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u200915\u00b716 1 \u2009+\u20091\u00b716 0 \u2009=\u2009241 , and the numerical value of  100 f  is  1\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u20090\u00b716 1 \u2009+\u200915\u00b716 0 \u2009=\u20094111 . Since  3870\u2009+\u2009241\u2009=\u20094111  and  00 f 1  is a permutation of  100 f ,  00 f 1  is a valid answer to the second test case. E. Hex Dyslexia time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Copying large hexadecimal (base 16) strings by hand can be error prone, but that doesn't stop people from doing it. You've discovered a bug in the code that was likely caused by someone making a mistake when copying such a string. You suspect that whoever copied the string did not change any of the digits in the string, nor the length of the string, but may have permuted the digits arbitrarily. For example, if the original string was  0 abc  they may have changed it to  a 0 cb  or  0 bca , but not  abc  or  0 abb . Unfortunately you don't have access to the original string nor the copied string, but you do know the length of the strings and their numerical absolute difference. You will be given this difference as a hexadecimal string  S , which has been zero-extended to be equal in length to the original and copied strings. Determine the smallest possible numerical value of the original string. Input Input will contain a hexadecimal string  S  consisting only of digits  0  to  9  and lowercase English letters from  a  to  f , with length at most  14 . At least one of the characters is non-zero. Output If it is not possible, print \" NO \" (without quotes). Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct. Examples Input f1e Output NO Input 0f1e Output 00f1 Input 12d2c Output 00314 Note The numerical value of a hexadecimal string is computed by multiplying each digit by successive powers of  16 , starting with the rightmost digit, which is multiplied by  16 0 . Hexadecimal digits representing values greater than  9  are represented by letters:  a \u2009=\u200910,\u2009 b \u2009=\u200911,\u2009 c \u2009=\u200912,\u2009 d \u2009=\u200913,\u2009 e \u2009=\u200914,\u2009 f \u2009=\u200915 . For example, the numerical value of  0 f 1 e  is  0\u00b716 3 \u2009+\u200915\u00b716 2 \u2009+\u20091\u00b716 1 \u2009+\u200914\u00b716 0 \u2009=\u20093870 , the numerical value of  00 f 1  is  0\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u200915\u00b716 1 \u2009+\u20091\u00b716 0 \u2009=\u2009241 , and the numerical value of  100 f  is  1\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u20090\u00b716 1 \u2009+\u200915\u00b716 0 \u2009=\u20094111 . Since  3870\u2009+\u2009241\u2009=\u20094111  and  00 f 1  is a permutation of  100 f ,  00 f 1  is a valid answer to the second test case. E. Hex Dyslexia time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Copying large hexadecimal (base 16) strings by hand can be error prone, but that doesn't stop people from doing it. You've discovered a bug in the code that was likely caused by someone making a mistake when copying such a string. You suspect that whoever copied the string did not change any of the digits in the string, nor the length of the string, but may have permuted the digits arbitrarily. For example, if the original string was  0 abc  they may have changed it to  a 0 cb  or  0 bca , but not  abc  or  0 abb . Unfortunately you don't have access to the original string nor the copied string, but you do know the length of the strings and their numerical absolute difference. You will be given this difference as a hexadecimal string  S , which has been zero-extended to be equal in length to the original and copied strings. Determine the smallest possible numerical value of the original string. Input Input will contain a hexadecimal string  S  consisting only of digits  0  to  9  and lowercase English letters from  a  to  f , with length at most  14 . At least one of the characters is non-zero. Output If it is not possible, print \" NO \" (without quotes). Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct. Examples Input f1e Output NO Input 0f1e Output 00f1 Input 12d2c Output 00314 Note The numerical value of a hexadecimal string is computed by multiplying each digit by successive powers of  16 , starting with the rightmost digit, which is multiplied by  16 0 . Hexadecimal digits representing values greater than  9  are represented by letters:  a \u2009=\u200910,\u2009 b \u2009=\u200911,\u2009 c \u2009=\u200912,\u2009 d \u2009=\u200913,\u2009 e \u2009=\u200914,\u2009 f \u2009=\u200915 . For example, the numerical value of  0 f 1 e  is  0\u00b716 3 \u2009+\u200915\u00b716 2 \u2009+\u20091\u00b716 1 \u2009+\u200914\u00b716 0 \u2009=\u20093870 , the numerical value of  00 f 1  is  0\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u200915\u00b716 1 \u2009+\u20091\u00b716 0 \u2009=\u2009241 , and the numerical value of  100 f  is  1\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u20090\u00b716 1 \u2009+\u200915\u00b716 0 \u2009=\u20094111 . Since  3870\u2009+\u2009241\u2009=\u20094111  and  00 f 1  is a permutation of  100 f ,  00 f 1  is a valid answer to the second test case. E. Hex Dyslexia time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Copying large hexadecimal (base 16) strings by hand can be error prone, but that doesn't stop people from doing it. You've discovered a bug in the code that was likely caused by someone making a mistake when copying such a string. You suspect that whoever copied the string did not change any of the digits in the string, nor the length of the string, but may have permuted the digits arbitrarily. For example, if the original string was  0 abc  they may have changed it to  a 0 cb  or  0 bca , but not  abc  or  0 abb . Unfortunately you don't have access to the original string nor the copied string, but you do know the length of the strings and their numerical absolute difference. You will be given this difference as a hexadecimal string  S , which has been zero-extended to be equal in length to the original and copied strings. Determine the smallest possible numerical value of the original string. Input Input will contain a hexadecimal string  S  consisting only of digits  0  to  9  and lowercase English letters from  a  to  f , with length at most  14 . At least one of the characters is non-zero. Output If it is not possible, print \" NO \" (without quotes). Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct. Examples Input f1e Output NO Input 0f1e Output 00f1 Input 12d2c Output 00314 Note The numerical value of a hexadecimal string is computed by multiplying each digit by successive powers of  16 , starting with the rightmost digit, which is multiplied by  16 0 . Hexadecimal digits representing values greater than  9  are represented by letters:  a \u2009=\u200910,\u2009 b \u2009=\u200911,\u2009 c \u2009=\u200912,\u2009 d \u2009=\u200913,\u2009 e \u2009=\u200914,\u2009 f \u2009=\u200915 . For example, the numerical value of  0 f 1 e  is  0\u00b716 3 \u2009+\u200915\u00b716 2 \u2009+\u20091\u00b716 1 \u2009+\u200914\u00b716 0 \u2009=\u20093870 , the numerical value of  00 f 1  is  0\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u200915\u00b716 1 \u2009+\u20091\u00b716 0 \u2009=\u2009241 , and the numerical value of  100 f  is  1\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u20090\u00b716 1 \u2009+\u200915\u00b716 0 \u2009=\u20094111 . Since  3870\u2009+\u2009241\u2009=\u20094111  and  00 f 1  is a permutation of  100 f ,  00 f 1  is a valid answer to the second test case. E. Hex Dyslexia time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Copying large hexadecimal (base 16) strings by hand can be error prone, but that doesn't stop people from doing it. You've discovered a bug in the code that was likely caused by someone making a mistake when copying such a string. You suspect that whoever copied the string did not change any of the digits in the string, nor the length of the string, but may have permuted the digits arbitrarily. For example, if the original string was  0 abc  they may have changed it to  a 0 cb  or  0 bca , but not  abc  or  0 abb . Unfortunately you don't have access to the original string nor the copied string, but you do know the length of the strings and their numerical absolute difference. You will be given this difference as a hexadecimal string  S , which has been zero-extended to be equal in length to the original and copied strings. Determine the smallest possible numerical value of the original string. Input Input will contain a hexadecimal string  S  consisting only of digits  0  to  9  and lowercase English letters from  a  to  f , with length at most  14 . At least one of the characters is non-zero. Output If it is not possible, print \" NO \" (without quotes). Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct. Examples Input f1e Output NO Input 0f1e Output 00f1 Input 12d2c Output 00314 Note The numerical value of a hexadecimal string is computed by multiplying each digit by successive powers of  16 , starting with the rightmost digit, which is multiplied by  16 0 . Hexadecimal digits representing values greater than  9  are represented by letters:  a \u2009=\u200910,\u2009 b \u2009=\u200911,\u2009 c \u2009=\u200912,\u2009 d \u2009=\u200913,\u2009 e \u2009=\u200914,\u2009 f \u2009=\u200915 . For example, the numerical value of  0 f 1 e  is  0\u00b716 3 \u2009+\u200915\u00b716 2 \u2009+\u20091\u00b716 1 \u2009+\u200914\u00b716 0 \u2009=\u20093870 , the numerical value of  00 f 1  is  0\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u200915\u00b716 1 \u2009+\u20091\u00b716 0 \u2009=\u2009241 , and the numerical value of  100 f  is  1\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u20090\u00b716 1 \u2009+\u200915\u00b716 0 \u2009=\u20094111 . Since  3870\u2009+\u2009241\u2009=\u20094111  and  00 f 1  is a permutation of  100 f ,  00 f 1  is a valid answer to the second test case. E. Hex Dyslexia time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Copying large hexadecimal (base 16) strings by hand can be error prone, but that doesn't stop people from doing it. You've discovered a bug in the code that was likely caused by someone making a mistake when copying such a string. You suspect that whoever copied the string did not change any of the digits in the string, nor the length of the string, but may have permuted the digits arbitrarily. For example, if the original string was  0 abc  they may have changed it to  a 0 cb  or  0 bca , but not  abc  or  0 abb . Unfortunately you don't have access to the original string nor the copied string, but you do know the length of the strings and their numerical absolute difference. You will be given this difference as a hexadecimal string  S , which has been zero-extended to be equal in length to the original and copied strings. Determine the smallest possible numerical value of the original string. Input Input will contain a hexadecimal string  S  consisting only of digits  0  to  9  and lowercase English letters from  a  to  f , with length at most  14 . At least one of the characters is non-zero. Output If it is not possible, print \" NO \" (without quotes). Otherwise, print the lowercase hexadecimal string corresponding to the smallest possible numerical value, including any necessary leading zeros for the length to be correct. Examples Input f1e Output NO Input 0f1e Output 00f1 Input 12d2c Output 00314 Note The numerical value of a hexadecimal string is computed by multiplying each digit by successive powers of  16 , starting with the rightmost digit, which is multiplied by  16 0 . Hexadecimal digits representing values greater than  9  are represented by letters:  a \u2009=\u200910,\u2009 b \u2009=\u200911,\u2009 c \u2009=\u200912,\u2009 d \u2009=\u200913,\u2009 e \u2009=\u200914,\u2009 f \u2009=\u200915 . For example, the numerical value of  0 f 1 e  is  0\u00b716 3 \u2009+\u200915\u00b716 2 \u2009+\u20091\u00b716 1 \u2009+\u200914\u00b716 0 \u2009=\u20093870 , the numerical value of  00 f 1  is  0\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u200915\u00b716 1 \u2009+\u20091\u00b716 0 \u2009=\u2009241 , and the numerical value of  100 f  is  1\u00b716 3 \u2009+\u20090\u00b716 2 \u2009+\u20090\u00b716 1 \u2009+\u200915\u00b716 0 \u2009=\u20094111 . Since  3870\u2009+\u2009241\u2009=\u20094111  and  00 f 1  is a permutation of  100 f ,  00 f 1  is a valid answer to the second test case.", "memory-limit": 256}