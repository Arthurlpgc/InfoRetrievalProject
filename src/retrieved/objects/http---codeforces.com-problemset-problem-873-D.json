{"title": "Merge Sort", "time-limit": 2000, "memory-limit": 256, "props": {"as follows": "    If the ", "Server time": "  Dec"}, "statement": "D. Merge Sort time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array  a  with indices from  [ l ,\u2009 r )  can be implemented as follows:    If the segment  [ l ,\u2009 r )  is already sorted in non-descending order (that is, for any  i  such that  l \u2009\u2264\u2009 i \u2009<\u2009 r \u2009-\u20091   a [ i ]\u2009\u2264\u2009 a [ i \u2009+\u20091] ), then end the function call;   Let  ;   Call  mergesort ( a ,\u2009 l ,\u2009 mid ) ;   Call  mergesort ( a ,\u2009 mid ,\u2009 r ) ;   Merge segments  [ l ,\u2009 mid )  and  [ mid ,\u2009 r ) , making the segment  [ l ,\u2009 r )  sorted in non-descending order. The merge algorithm doesn't call any other functions.  The array in this problem is  0 -indexed, so to sort the whole array, you need to call  mergesort ( a ,\u20090,\u2009 n ) . The number of calls of function  mergesort  is very important, so Ivan has decided to calculate it while sorting the array. For example, if  a \u2009=\u2009{1,\u20092,\u20093,\u20094} , then there will be  1  call of  mergesort  \u2014  mergesort (0,\u20094) , which will check that the array is sorted and then end. If  a \u2009=\u2009{2,\u20091,\u20093} , then the number of calls is  3 : first of all, you call  mergesort (0,\u20093) , which then sets  mid \u2009=\u20091  and calls  mergesort (0,\u20091)  and  mergesort (1,\u20093) , which do not perform any recursive calls because segments  (0,\u20091)  and  (1,\u20093)  are sorted. Ivan has implemented the program that counts the number of  mergesort  calls, but now he needs to test it. To do this, he needs to find an array  a  such that  a  is a permutation of size  n  (that is, the number of elements in  a  is  n , and every integer number from  [1,\u2009 n ]  can be found in this array), and the number of  mergesort  calls when sorting the array is exactly  k . Help Ivan to find an array he wants! Input The first line contains two numbers  n  and  k  ( 1\u2009\u2264\u2009 n \u2009\u2264\u2009100000 ,  1\u2009\u2264\u2009 k \u2009\u2264\u2009200000 ) \u2014 the size of a desired permutation and the number of  mergesort  calls required to sort it. Output If a permutation of size  n  such that there will be exactly  k  calls of  mergesort  while sorting it doesn't exist, output  \u2009-\u20091 . Otherwise output  n  integer numbers  a [0],\u2009 a [1],\u2009...,\u2009 a [ n \u2009-\u20091]  \u2014 the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them. Examples Input 3 3 Output 2 1 3  Input 4 1 Output 1 2 3 4  Input 5 6 Output -1 D. Merge Sort time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array  a  with indices from  [ l ,\u2009 r )  can be implemented as follows:    If the segment  [ l ,\u2009 r )  is already sorted in non-descending order (that is, for any  i  such that  l \u2009\u2264\u2009 i \u2009<\u2009 r \u2009-\u20091   a [ i ]\u2009\u2264\u2009 a [ i \u2009+\u20091] ), then end the function call;   Let  ;   Call  mergesort ( a ,\u2009 l ,\u2009 mid ) ;   Call  mergesort ( a ,\u2009 mid ,\u2009 r ) ;   Merge segments  [ l ,\u2009 mid )  and  [ mid ,\u2009 r ) , making the segment  [ l ,\u2009 r )  sorted in non-descending order. The merge algorithm doesn't call any other functions.  The array in this problem is  0 -indexed, so to sort the whole array, you need to call  mergesort ( a ,\u20090,\u2009 n ) . The number of calls of function  mergesort  is very important, so Ivan has decided to calculate it while sorting the array. For example, if  a \u2009=\u2009{1,\u20092,\u20093,\u20094} , then there will be  1  call of  mergesort  \u2014  mergesort (0,\u20094) , which will check that the array is sorted and then end. If  a \u2009=\u2009{2,\u20091,\u20093} , then the number of calls is  3 : first of all, you call  mergesort (0,\u20093) , which then sets  mid \u2009=\u20091  and calls  mergesort (0,\u20091)  and  mergesort (1,\u20093) , which do not perform any recursive calls because segments  (0,\u20091)  and  (1,\u20093)  are sorted. Ivan has implemented the program that counts the number of  mergesort  calls, but now he needs to test it. To do this, he needs to find an array  a  such that  a  is a permutation of size  n  (that is, the number of elements in  a  is  n , and every integer number from  [1,\u2009 n ]  can be found in this array), and the number of  mergesort  calls when sorting the array is exactly  k . Help Ivan to find an array he wants! Input The first line contains two numbers  n  and  k  ( 1\u2009\u2264\u2009 n \u2009\u2264\u2009100000 ,  1\u2009\u2264\u2009 k \u2009\u2264\u2009200000 ) \u2014 the size of a desired permutation and the number of  mergesort  calls required to sort it. Output If a permutation of size  n  such that there will be exactly  k  calls of  mergesort  while sorting it doesn't exist, output  \u2009-\u20091 . Otherwise output  n  integer numbers  a [0],\u2009 a [1],\u2009...,\u2009 a [ n \u2009-\u20091]  \u2014 the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them. Examples Input 3 3 Output 2 1 3  Input 4 1 Output 1 2 3 4  Input 5 6 Output -1 D. Merge Sort time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array  a  with indices from  [ l ,\u2009 r )  can be implemented as follows:    If the segment  [ l ,\u2009 r )  is already sorted in non-descending order (that is, for any  i  such that  l \u2009\u2264\u2009 i \u2009<\u2009 r \u2009-\u20091   a [ i ]\u2009\u2264\u2009 a [ i \u2009+\u20091] ), then end the function call;   Let  ;   Call  mergesort ( a ,\u2009 l ,\u2009 mid ) ;   Call  mergesort ( a ,\u2009 mid ,\u2009 r ) ;   Merge segments  [ l ,\u2009 mid )  and  [ mid ,\u2009 r ) , making the segment  [ l ,\u2009 r )  sorted in non-descending order. The merge algorithm doesn't call any other functions.  The array in this problem is  0 -indexed, so to sort the whole array, you need to call  mergesort ( a ,\u20090,\u2009 n ) . The number of calls of function  mergesort  is very important, so Ivan has decided to calculate it while sorting the array. For example, if  a \u2009=\u2009{1,\u20092,\u20093,\u20094} , then there will be  1  call of  mergesort  \u2014  mergesort (0,\u20094) , which will check that the array is sorted and then end. If  a \u2009=\u2009{2,\u20091,\u20093} , then the number of calls is  3 : first of all, you call  mergesort (0,\u20093) , which then sets  mid \u2009=\u20091  and calls  mergesort (0,\u20091)  and  mergesort (1,\u20093) , which do not perform any recursive calls because segments  (0,\u20091)  and  (1,\u20093)  are sorted. Ivan has implemented the program that counts the number of  mergesort  calls, but now he needs to test it. To do this, he needs to find an array  a  such that  a  is a permutation of size  n  (that is, the number of elements in  a  is  n , and every integer number from  [1,\u2009 n ]  can be found in this array), and the number of  mergesort  calls when sorting the array is exactly  k . Help Ivan to find an array he wants! Input The first line contains two numbers  n  and  k  ( 1\u2009\u2264\u2009 n \u2009\u2264\u2009100000 ,  1\u2009\u2264\u2009 k \u2009\u2264\u2009200000 ) \u2014 the size of a desired permutation and the number of  mergesort  calls required to sort it. Output If a permutation of size  n  such that there will be exactly  k  calls of  mergesort  while sorting it doesn't exist, output  \u2009-\u20091 . Otherwise output  n  integer numbers  a [0],\u2009 a [1],\u2009...,\u2009 a [ n \u2009-\u20091]  \u2014 the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them. Examples Input 3 3 Output 2 1 3  Input 4 1 Output 1 2 3 4  Input 5 6 Output -1 D. Merge Sort time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array  a  with indices from  [ l ,\u2009 r )  can be implemented as follows:    If the segment  [ l ,\u2009 r )  is already sorted in non-descending order (that is, for any  i  such that  l \u2009\u2264\u2009 i \u2009<\u2009 r \u2009-\u20091   a [ i ]\u2009\u2264\u2009 a [ i \u2009+\u20091] ), then end the function call;   Let  ;   Call  mergesort ( a ,\u2009 l ,\u2009 mid ) ;   Call  mergesort ( a ,\u2009 mid ,\u2009 r ) ;   Merge segments  [ l ,\u2009 mid )  and  [ mid ,\u2009 r ) , making the segment  [ l ,\u2009 r )  sorted in non-descending order. The merge algorithm doesn't call any other functions.  The array in this problem is  0 -indexed, so to sort the whole array, you need to call  mergesort ( a ,\u20090,\u2009 n ) . The number of calls of function  mergesort  is very important, so Ivan has decided to calculate it while sorting the array. For example, if  a \u2009=\u2009{1,\u20092,\u20093,\u20094} , then there will be  1  call of  mergesort  \u2014  mergesort (0,\u20094) , which will check that the array is sorted and then end. If  a \u2009=\u2009{2,\u20091,\u20093} , then the number of calls is  3 : first of all, you call  mergesort (0,\u20093) , which then sets  mid \u2009=\u20091  and calls  mergesort (0,\u20091)  and  mergesort (1,\u20093) , which do not perform any recursive calls because segments  (0,\u20091)  and  (1,\u20093)  are sorted. Ivan has implemented the program that counts the number of  mergesort  calls, but now he needs to test it. To do this, he needs to find an array  a  such that  a  is a permutation of size  n  (that is, the number of elements in  a  is  n , and every integer number from  [1,\u2009 n ]  can be found in this array), and the number of  mergesort  calls when sorting the array is exactly  k . Help Ivan to find an array he wants! Input The first line contains two numbers  n  and  k  ( 1\u2009\u2264\u2009 n \u2009\u2264\u2009100000 ,  1\u2009\u2264\u2009 k \u2009\u2264\u2009200000 ) \u2014 the size of a desired permutation and the number of  mergesort  calls required to sort it. Output If a permutation of size  n  such that there will be exactly  k  calls of  mergesort  while sorting it doesn't exist, output  \u2009-\u20091 . Otherwise output  n  integer numbers  a [0],\u2009 a [1],\u2009...,\u2009 a [ n \u2009-\u20091]  \u2014 the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them. Examples Input 3 3 Output 2 1 3  Input 4 1 Output 1 2 3 4  Input 5 6 Output -1 D. Merge Sort time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array  a  with indices from  [ l ,\u2009 r )  can be implemented as follows:    If the segment  [ l ,\u2009 r )  is already sorted in non-descending order (that is, for any  i  such that  l \u2009\u2264\u2009 i \u2009<\u2009 r \u2009-\u20091   a [ i ]\u2009\u2264\u2009 a [ i \u2009+\u20091] ), then end the function call;   Let  ;   Call  mergesort ( a ,\u2009 l ,\u2009 mid ) ;   Call  mergesort ( a ,\u2009 mid ,\u2009 r ) ;   Merge segments  [ l ,\u2009 mid )  and  [ mid ,\u2009 r ) , making the segment  [ l ,\u2009 r )  sorted in non-descending order. The merge algorithm doesn't call any other functions.  The array in this problem is  0 -indexed, so to sort the whole array, you need to call  mergesort ( a ,\u20090,\u2009 n ) . The number of calls of function  mergesort  is very important, so Ivan has decided to calculate it while sorting the array. For example, if  a \u2009=\u2009{1,\u20092,\u20093,\u20094} , then there will be  1  call of  mergesort  \u2014  mergesort (0,\u20094) , which will check that the array is sorted and then end. If  a \u2009=\u2009{2,\u20091,\u20093} , then the number of calls is  3 : first of all, you call  mergesort (0,\u20093) , which then sets  mid \u2009=\u20091  and calls  mergesort (0,\u20091)  and  mergesort (1,\u20093) , which do not perform any recursive calls because segments  (0,\u20091)  and  (1,\u20093)  are sorted. Ivan has implemented the program that counts the number of  mergesort  calls, but now he needs to test it. To do this, he needs to find an array  a  such that  a  is a permutation of size  n  (that is, the number of elements in  a  is  n , and every integer number from  [1,\u2009 n ]  can be found in this array), and the number of  mergesort  calls when sorting the array is exactly  k . Help Ivan to find an array he wants! Input The first line contains two numbers  n  and  k  ( 1\u2009\u2264\u2009 n \u2009\u2264\u2009100000 ,  1\u2009\u2264\u2009 k \u2009\u2264\u2009200000 ) \u2014 the size of a desired permutation and the number of  mergesort  calls required to sort it. Output If a permutation of size  n  such that there will be exactly  k  calls of  mergesort  while sorting it doesn't exist, output  \u2009-\u20091 . Otherwise output  n  integer numbers  a [0],\u2009 a [1],\u2009...,\u2009 a [ n \u2009-\u20091]  \u2014 the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them. Examples Input 3 3 Output 2 1 3  Input 4 1 Output 1 2 3 4  Input 5 6 Output -1 D. Merge Sort time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array  a  with indices from  [ l ,\u2009 r )  can be implemented as follows:    If the segment  [ l ,\u2009 r )  is already sorted in non-descending order (that is, for any  i  such that  l \u2009\u2264\u2009 i \u2009<\u2009 r \u2009-\u20091   a [ i ]\u2009\u2264\u2009 a [ i \u2009+\u20091] ), then end the function call;   Let  ;   Call  mergesort ( a ,\u2009 l ,\u2009 mid ) ;   Call  mergesort ( a ,\u2009 mid ,\u2009 r ) ;   Merge segments  [ l ,\u2009 mid )  and  [ mid ,\u2009 r ) , making the segment  [ l ,\u2009 r )  sorted in non-descending order. The merge algorithm doesn't call any other functions.  The array in this problem is  0 -indexed, so to sort the whole array, you need to call  mergesort ( a ,\u20090,\u2009 n ) . The number of calls of function  mergesort  is very important, so Ivan has decided to calculate it while sorting the array. For example, if  a \u2009=\u2009{1,\u20092,\u20093,\u20094} , then there will be  1  call of  mergesort  \u2014  mergesort (0,\u20094) , which will check that the array is sorted and then end. If  a \u2009=\u2009{2,\u20091,\u20093} , then the number of calls is  3 : first of all, you call  mergesort (0,\u20093) , which then sets  mid \u2009=\u20091  and calls  mergesort (0,\u20091)  and  mergesort (1,\u20093) , which do not perform any recursive calls because segments  (0,\u20091)  and  (1,\u20093)  are sorted. Ivan has implemented the program that counts the number of  mergesort  calls, but now he needs to test it. To do this, he needs to find an array  a  such that  a  is a permutation of size  n  (that is, the number of elements in  a  is  n , and every integer number from  [1,\u2009 n ]  can be found in this array), and the number of  mergesort  calls when sorting the array is exactly  k . Help Ivan to find an array he wants! Input The first line contains two numbers  n  and  k  ( 1\u2009\u2264\u2009 n \u2009\u2264\u2009100000 ,  1\u2009\u2264\u2009 k \u2009\u2264\u2009200000 ) \u2014 the size of a desired permutation and the number of  mergesort  calls required to sort it. Output If a permutation of size  n  such that there will be exactly  k  calls of  mergesort  while sorting it doesn't exist, output  \u2009-\u20091 . Otherwise output  n  integer numbers  a [0],\u2009 a [1],\u2009...,\u2009 a [ n \u2009-\u20091]  \u2014 the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them. Examples Input 3 3 Output 2 1 3  Input 4 1 Output 1 2 3 4  Input 5 6 Output -1 D. Merge Sort time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array  a  with indices from  [ l ,\u2009 r )  can be implemented as follows:    If the segment  [ l ,\u2009 r )  is already sorted in non-descending order (that is, for any  i  such that  l \u2009\u2264\u2009 i \u2009<\u2009 r \u2009-\u20091   a [ i ]\u2009\u2264\u2009 a [ i \u2009+\u20091] ), then end the function call;   Let  ;   Call  mergesort ( a ,\u2009 l ,\u2009 mid ) ;   Call  mergesort ( a ,\u2009 mid ,\u2009 r ) ;   Merge segments  [ l ,\u2009 mid )  and  [ mid ,\u2009 r ) , making the segment  [ l ,\u2009 r )  sorted in non-descending order. The merge algorithm doesn't call any other functions.  The array in this problem is  0 -indexed, so to sort the whole array, you need to call  mergesort ( a ,\u20090,\u2009 n ) . The number of calls of function  mergesort  is very important, so Ivan has decided to calculate it while sorting the array. For example, if  a \u2009=\u2009{1,\u20092,\u20093,\u20094} , then there will be  1  call of  mergesort  \u2014  mergesort (0,\u20094) , which will check that the array is sorted and then end. If  a \u2009=\u2009{2,\u20091,\u20093} , then the number of calls is  3 : first of all, you call  mergesort (0,\u20093) , which then sets  mid \u2009=\u20091  and calls  mergesort (0,\u20091)  and  mergesort (1,\u20093) , which do not perform any recursive calls because segments  (0,\u20091)  and  (1,\u20093)  are sorted. Ivan has implemented the program that counts the number of  mergesort  calls, but now he needs to test it. To do this, he needs to find an array  a  such that  a  is a permutation of size  n  (that is, the number of elements in  a  is  n , and every integer number from  [1,\u2009 n ]  can be found in this array), and the number of  mergesort  calls when sorting the array is exactly  k . Help Ivan to find an array he wants! Input The first line contains two numbers  n  and  k  ( 1\u2009\u2264\u2009 n \u2009\u2264\u2009100000 ,  1\u2009\u2264\u2009 k \u2009\u2264\u2009200000 ) \u2014 the size of a desired permutation and the number of  mergesort  calls required to sort it. Output If a permutation of size  n  such that there will be exactly  k  calls of  mergesort  while sorting it doesn't exist, output  \u2009-\u20091 . Otherwise output  n  integer numbers  a [0],\u2009 a [1],\u2009...,\u2009 a [ n \u2009-\u20091]  \u2014 the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them. Examples Input 3 3 Output 2 1 3  Input 4 1 Output 1 2 3 4  Input 5 6 Output -1 D. Merge Sort time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array  a  with indices from  [ l ,\u2009 r )  can be implemented as follows:    If the segment  [ l ,\u2009 r )  is already sorted in non-descending order (that is, for any  i  such that  l \u2009\u2264\u2009 i \u2009<\u2009 r \u2009-\u20091   a [ i ]\u2009\u2264\u2009 a [ i \u2009+\u20091] ), then end the function call;   Let  ;   Call  mergesort ( a ,\u2009 l ,\u2009 mid ) ;   Call  mergesort ( a ,\u2009 mid ,\u2009 r ) ;   Merge segments  [ l ,\u2009 mid )  and  [ mid ,\u2009 r ) , making the segment  [ l ,\u2009 r )  sorted in non-descending order. The merge algorithm doesn't call any other functions.  The array in this problem is  0 -indexed, so to sort the whole array, you need to call  mergesort ( a ,\u20090,\u2009 n ) . The number of calls of function  mergesort  is very important, so Ivan has decided to calculate it while sorting the array. For example, if  a \u2009=\u2009{1,\u20092,\u20093,\u20094} , then there will be  1  call of  mergesort  \u2014  mergesort (0,\u20094) , which will check that the array is sorted and then end. If  a \u2009=\u2009{2,\u20091,\u20093} , then the number of calls is  3 : first of all, you call  mergesort (0,\u20093) , which then sets  mid \u2009=\u20091  and calls  mergesort (0,\u20091)  and  mergesort (1,\u20093) , which do not perform any recursive calls because segments  (0,\u20091)  and  (1,\u20093)  are sorted. Ivan has implemented the program that counts the number of  mergesort  calls, but now he needs to test it. To do this, he needs to find an array  a  such that  a  is a permutation of size  n  (that is, the number of elements in  a  is  n , and every integer number from  [1,\u2009 n ]  can be found in this array), and the number of  mergesort  calls when sorting the array is exactly  k . Help Ivan to find an array he wants! Input The first line contains two numbers  n  and  k  ( 1\u2009\u2264\u2009 n \u2009\u2264\u2009100000 ,  1\u2009\u2264\u2009 k \u2009\u2264\u2009200000 ) \u2014 the size of a desired permutation and the number of  mergesort  calls required to sort it. Output If a permutation of size  n  such that there will be exactly  k  calls of  mergesort  while sorting it doesn't exist, output  \u2009-\u20091 . Otherwise output  n  integer numbers  a [0],\u2009 a [1],\u2009...,\u2009 a [ n \u2009-\u20091]  \u2014 the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them. Examples Input 3 3 Output 2 1 3  Input 4 1 Output 1 2 3 4  Input 5 6 Output -1"}